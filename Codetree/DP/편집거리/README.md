# 편집거리
#### 코드트리 Intermediate Low / DP II / String Matching



#### 0. 문제 핵심

dp[i][j] 를 어떻게 정의하냐가 가장 큰 핵심이다.

문자열 A, B가 있다고 했을 때,
A의 i번째 문자와 B의 j번째 문자가 같도록 연산한 **최소 횟수**라고 정의한다.


#### 1. 초기값 정의

```c++
// 문자열 B가 비어있다고 한다면, 문자열 A의 '삭제 연산' 횟수
for(int i=0; i<=a.size(); i++){ 
        dp[i][0] = i;
    }

// 문자열 A가 비어있다고 한다면, 문자열 B의 '삽입 연산' 횟수
for(int j=0; j<=b.size(); j++){
    dp[0][j] = j;
}
```

#### 2. 점화식 정의
```c++
if(a[i-1] == b[j-1]){ // 만약 문자가 같다면 연산할 필요가 없으므로 그대로 저장한다.
    dp[i][j] = dp[i-1][j-1];
}
else { // 문자가 다르다면 삭제/삽입/변경 횟수 중에 작은 것을 저장한다.
    dp[i][j] = min({dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+1});
}
```

#### 3. 정답
```c++
dp[a.size()][b.size()];
```
